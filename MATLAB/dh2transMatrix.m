function [ transMatrix ] = dh2transMatrix( theta, d, alpha, a , unit_angle)
%dh2transMatrix Function to generate transformation matrix based on
%DH-convention
%   The function accepts 4 DH parameters and return a transformation matrix
%   that map the frame n with respect to frame n-1
%   theta = rotation about old z axis (in rad or degree)
%   d = translation along old z axis
%   alpha = rotation about new x axis (in rad or degree)
%   a = translation along new x axis
%   unit_angle = to make the function modular/works for both radian and
%   degree. Input of 1 will make the function works with radian, and 2 will
%   be degree. This modularity is necessary because cos(pi/2) returns 
%   6.1232e-017 and sin(pi) returns 1.2246e-016 instead of zeros. I tried
%   to use cosd and sind functions that accept angle in degree but I can't
%   use them for symbolic operation.

if unit_angle == 1
    rotOldZAxis = [cos(theta) -sin(theta) 0 0;...
    sin(theta) cos(theta) 0 0;...
    0 0 1 0;...
    0 0 0 1];
    translationOldZAxis = [1 0 0 0;...
    0 1 0 0;...
    0 0 1 d;...
    0 0 0 1];
    translationNewXAxis = [1 0 0 a;...
    0 1 0 0;...
    0 0 1 0;...
    0 0 0 1];
    rotNewXAxis = [1 0 0 0;...
    0 cos(alpha) -sin(alpha) 0;...
    0 sin(alpha) cos(alpha) 0;...
    0 0 0 1];
elseif unit_angle == 2
    rotOldZAxis = [cosd(theta) -sind(theta) 0 0;...
    sind(theta) cosd(theta) 0 0;...
    0 0 1 0;...
    0 0 0 1];
    translationOldZAxis = [1 0 0 0;...
    0 1 0 0;...
    0 0 1 d;...
    0 0 0 1];
    translationNewXAxis = [1 0 0 a;...
    0 1 0 0;...
    0 0 1 0;...
    0 0 0 1];
    rotNewXAxis = [1 0 0 0;...
    0 cosd(alpha) -sind(alpha) 0;...
    0 sind(alpha) cosd(alpha) 0;...
    0 0 0 1];
else
    disp('Error: Specify your angle unit option!');
end
transMatrix = rotOldZAxis*translationOldZAxis*translationNewXAxis*rotNewXAxis;
end